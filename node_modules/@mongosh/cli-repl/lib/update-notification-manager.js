"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateNotificationManager = void 0;
const semver_1 = __importDefault(require("semver"));
const fs_1 = require("fs");
const node_fetch_1 = __importDefault(require("node-fetch"));
class UpdateNotificationManager {
    constructor() {
        this.latestKnownMongoshVersion = undefined;
        this.localFilesystemFetchInProgress = undefined;
    }
    async getLatestVersionIfMoreRecent(currentVersion) {
        try {
            await this.localFilesystemFetchInProgress;
        }
        catch (_a) {
        }
        if (!this.latestKnownMongoshVersion)
            return null;
        if (currentVersion &&
            !semver_1.default.gt(this.latestKnownMongoshVersion, currentVersion))
            return null;
        if (currentVersion && semver_1.default.prerelease(currentVersion))
            return null;
        return this.latestKnownMongoshVersion;
    }
    async fetchUpdateMetadata(updateURL, localFilePath) {
        var _a, _b, _c, _d, _e;
        let localFileContents;
        await (this.localFilesystemFetchInProgress = (async () => {
            let localFileText = '';
            try {
                localFileText = await fs_1.promises.readFile(localFilePath, 'utf-8');
            }
            catch (err) {
                if (!(err &&
                    typeof err === 'object' &&
                    'code' in err &&
                    err.code === 'ENOENT'))
                    throw err;
            }
            try {
                localFileContents = JSON.parse(localFileText);
            }
            catch (_a) {
            }
            if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.updateURL) !== updateURL) {
                localFileContents = undefined;
            }
            if (localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.latestKnownMongoshVersion) {
                this.latestKnownMongoshVersion =
                    localFileContents.latestKnownMongoshVersion;
            }
            this.localFilesystemFetchInProgress = undefined;
        })());
        if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.lastChecked) &&
            Date.now() - localFileContents.lastChecked < 86400000) {
            return;
        }
        const response = await (0, node_fetch_1.default)(updateURL, {
            headers: (localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.etag)
                ? { 'if-none-match': localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.etag }
                : {},
        });
        if (response.status === 304) {
            response.body
                .on('error', () => {
            })
                .resume();
            localFileContents = { ...localFileContents, lastChecked: Date.now() };
            await fs_1.promises.writeFile(localFilePath, JSON.stringify(localFileContents));
            return;
        }
        if (!response.ok) {
            throw new Error(`Unexpected status code fetching ${updateURL}: ${response.status} ${response.statusText}`);
        }
        const jsonContents = await response.json();
        this.latestKnownMongoshVersion = (_d = (_c = (_b = (_a = jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.versions) === null || _a === void 0 ? void 0 : _a.map((v) => v.version)) === null || _b === void 0 ? void 0 : _b.filter((v) => !semver_1.default.prerelease(v))) === null || _c === void 0 ? void 0 : _c.sort(semver_1.default.rcompare)) === null || _d === void 0 ? void 0 : _d[0];
        localFileContents = {
            updateURL,
            lastChecked: Date.now(),
            etag: (_e = response.headers.get('etag')) !== null && _e !== void 0 ? _e : undefined,
            latestKnownMongoshVersion: this.latestKnownMongoshVersion,
        };
        await fs_1.promises.writeFile(localFilePath, JSON.stringify(localFileContents));
    }
}
exports.UpdateNotificationManager = UpdateNotificationManager;
//# sourceMappingURL=update-notification-manager.js.map